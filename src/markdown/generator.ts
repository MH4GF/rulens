import fs from 'node:fs/promises'
import path from 'node:path'
import type { RulensLinter } from '@/types/rulens.ts'
import { ResultAsync, err, ok } from 'neverthrow'
import { Logger } from '../utils/logger.ts'
import { lintRulesToMarkdown } from './lint-to-markdown.ts'

interface MarkdownGeneratorOptions {
  linters: RulensLinter[]
  outputFile: string
}

/**
 * Generate table of contents
 */
function generateTableOfContents(linters: RulensLinter[]): string {
  let toc = '## ğŸ“‘ Table of Contents\n\n'

  toc += '- [Introduction](#introduction)\n'
  toc += '- [AI Usage Guide](#ai-usage-guide)\n'

  // å„Linterã«å¯¾ã—ã¦ç›®æ¬¡ã‚¨ãƒ³ãƒˆãƒªã‚’è¿½åŠ 
  for (const linter of linters) {
    const anchorName = `${linter.name.toLowerCase()}-rules`
    toc += `- [${linter.name} Rules](#${anchorName})\n`
    // It's possible to enumerate all categories, but keeping it simple
  }

  return toc
}

/**
 * Generate document header
 */
function generateHeader(): string {
  return '# Project Lint Rules Reference\n\n## ğŸ“‹ Document Overview\n\nThis document contains a comprehensive catalog of linting rules enabled in this project. It is automatically generated by [Rulens](https://github.com/MH4GF/rulens) and provides AI code assistants and developers with detailed information about code style and quality requirements.\n\n'
}

/**
 * Generate introduction
 */
function generateIntroduction(): string {
  return (
    '## ğŸ“– Introduction\n\n' +
    'This document lists all active linting rules configured in the project. Each rule includes:\n\n' +
    '- A link to official documentation\n' +
    '- A brief description of what the rule enforces\n' +
    '- Severity level (when available)\n\n' +
    'Use this reference to understand the code standards and avoid common issues when writing or reviewing code.\n\n'
  )
}

/**
 * Generate AI usage guide
 */
function generateAIUsageGuide(): string {
  return (
    '## ğŸ¤– AI Usage Guide\n\n' +
    '**For AI Code Assistants**: When generating code for this project, please adhere to the following guidelines:\n\n' +
    `1. **Scan relevant categories first**: Focus on rules in categories related to the code you're generating.\n` +
    '2. **Respect all rules**: Ensure all generated code follows all linting rules.\n' +
    '3. **Avoid common pitfalls**: Check complexity rules to avoid anti-patterns.\n\n' +
    'When uncertain about specific rules, refer to the rule documentation links provided.\n\n'
  )
}

/**
 * Ensure directory exists before writing file
 * Returns ResultAsync with void on success or Error on failure
 */
function ensureDirectoryExists(filePath: string): ResultAsync<void, Error> {
  const directory = path.dirname(filePath)

  return ResultAsync.fromPromise(
    fs.mkdir(directory, { recursive: true }).then(() => undefined),
    (error): Error => (error instanceof Error ? error : new Error(String(error))),
  ).orElse((error) => {
    // Ignore error if directory already exists
    if ((error as NodeJS.ErrnoException).code === 'EEXIST') {
      return ok(undefined)
    }
    return err(error)
  })
}

/**
 * ç´”ç²‹ãªé–¢æ•°ï¼šãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³æ–‡å­—åˆ—ã‚’ç”Ÿæˆã™ã‚‹
 * ãƒ†ã‚¹ãƒˆå¯èƒ½æ€§ã‚’é«˜ã‚ã‚‹ãŸã‚ã«å‰¯ä½œç”¨ã‚’å«ã¾ãªã„
 */
export function generateMarkdownContent(options: {
  linters: RulensLinter[]
}): string {
  const { linters } = options

  // Generate each part of the document
  let markdown = generateHeader()
  markdown += '---\n\n'

  // Add table of contents
  markdown += generateTableOfContents(linters)
  markdown += '---\n\n'

  // Add introduction and AI usage guide
  markdown += generateIntroduction()
  markdown += '---\n\n'
  markdown += generateAIUsageGuide()
  markdown += '---\n\n'

  // å„Linterã®ãƒ«ãƒ¼ãƒ«æƒ…å ±ã‚’ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã«å¤‰æ›
  for (let i = 0; i < linters.length; i++) {
    const linter = linters[i]
    // å‹ãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ç¢ºå®Ÿã«RulensLinterã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
    if (linter?.name && Array.isArray(linter.categories)) {
      markdown += `${lintRulesToMarkdown(linter, true)}`

      // æœ€å¾Œã®linterä»¥å¤–ã¯æ”¹è¡Œã‚’è¿½åŠ 
      if (i < linters.length - 1) {
        markdown += '\n'
      }
    }
  }

  return markdown
}

/**
 * ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ æ“ä½œã‚’è¡Œã†é–¢æ•°ï¼šãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€
 */
export function writeMarkdownToFile(outputFile: string, content: string): ResultAsync<void, Error> {
  return ensureDirectoryExists(outputFile).andThen(() => {
    return ResultAsync.fromPromise(
      fs.writeFile(outputFile, content, 'utf-8'),
      (error): Error => (error instanceof Error ? error : new Error(String(error))),
    )
  })
}

/**
 * æ—¢å­˜ã®é–¢æ•°ï¼šãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³ã‚’ç”Ÿæˆã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã‚€
 */
export function generateMarkdown(options: MarkdownGeneratorOptions): ResultAsync<string, Error> {
  const { linters, outputFile } = options
  const logger = new Logger()

  logger.info(`Generating markdown for ${outputFile}...`)

  // ãƒãƒ¼ã‚¯ãƒ€ã‚¦ãƒ³å†…å®¹ã‚’ç”Ÿæˆ
  const markdown = generateMarkdownContent({ linters })

  // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
  return writeMarkdownToFile(outputFile, markdown).map(() => markdown)
}
